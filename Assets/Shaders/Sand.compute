#pragma kernel Init
#pragma kernel Next
#pragma kernel ClearGreenChannel
#pragma kernel ApplyBuffer

#include "Random.cginc"
#define INIT_GRAVITY_MAX 10.0
#define COLLISION_GRAVITY_MAX 5.0

float _Resolution;
RWTexture2D<float4> _Result;
sampler2D _GridBuffer;
float4 _SpawnData; // XY = Position, Z = Radius, W = Type.

float4 GetUV(uint3 id)
{
    return float4(id.xy / _Resolution, 0, 0);
}

float4 SampleNeighbour(float4 position, float dx, float dy)
{
    return tex2Dlod(_GridBuffer, position + float4(dx, dy, 0, 0));
}

float Distance(float2 a, float2 b)
{
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

void MoveDown(uint3 id, float4 state)
{
    _Result[id.xy] = float4(0, 1, 0, 0);
    _Result[id.xy - uint2(0, state.b)] = float4(1, 1, state.b, 0);
}
void MoveDownLeft(uint3 id, float4 state)
{
    _Result[id.xy] = float4(0, 1, 0, 0);
    _Result[id.xy - uint2(1, 1)] = float4(1, 1, floor(random(id.xy) * COLLISION_GRAVITY_MAX), 0);
}
void MoveDownRight(uint3 id, float4 state)
{
    _Result[id.xy] = float4(0, 1, 0, 0);
    _Result[id.xy - uint2(-1, 1)] = float4(1, 1, floor(random(id.xy) * COLLISION_GRAVITY_MAX), 0);
}

[numthreads(8,8,1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    _Result[id.xy] = 0;
}

[numthreads(8,8,1)]
void Next(uint3 id : SV_DispatchThreadID)
{
    float4 uv = GetUV(id);
    float delta = 1.0 / _Resolution; // Cells neighbour distance.
    
    float4 state = tex2Dlod(_GridBuffer, uv);

    if (uv.y == 0)
    {
        _Result[id.xy] = float4(state.rg, 0, state.a); // Nullify gravity.
        return;
    }

    state.b += 1; // Increase gravity.
    
    if (state.r == 1)
    {
        int downObstacleDistance = 0;
        for (int i = 1; i <= state.b; ++i)
        {
            if (SampleNeighbour(uv, 0, -delta * i).r != 0) // Obstacle below.
                break;

            downObstacleDistance++;

            if (uv.y - delta * i == 0) // Bottom reached.
                break;
        }

        if (downObstacleDistance > 0)
        {
            state.b = min(downObstacleDistance, state.b);
            MoveDown(id, state);
        }
        else
        {
            float4 downRightState = SampleNeighbour(uv, delta, -delta);
            float4 downLeftState = SampleNeighbour(uv, -delta, -delta);
            float4 rightState = SampleNeighbour(uv, delta, 0);
            float4 leftState = SampleNeighbour(uv, -delta, 0);

            if (random(id.xy) > 0.5)
            {
                if (downRightState.r == 0 && rightState.r == 0)
                    MoveDownRight(id, state);
                else if (downLeftState.r == 0 && leftState.r == 0)
                    MoveDownLeft(id, state);
            }
            else
            {
                if (downLeftState.r == 0 && leftState.r == 0)
                    MoveDownLeft(id, state);
                else if (downRightState.r == 0 && rightState.r == 0)
                    MoveDownRight(id, state);
            }
        }
    }

    if (_SpawnData.w > -1
        && (_SpawnData.w != 1 || random(uv.xy) < 0.5)
        && Distance(uv.xy, _SpawnData.xy) < (_SpawnData.z / 2) / _Resolution)
    {
        float spawnType = _SpawnData.w;
        if (spawnType == 3)
            spawnType = 0;
        
        _Result[id.xy] = float4(spawnType, 1, floor(random(id.xy) * INIT_GRAVITY_MAX), 0);
    }
}

[numthreads(8,8,1)]
void ClearGreenChannel(uint3 id : SV_DispatchThreadID)
{
    float4 uv = GetUV(id);
    float4 state = tex2Dlod(_GridBuffer, uv);
    _Result[id.xy] = float4(state.x, 0, state.zw);
}

[numthreads(8,8,1)]
void ApplyBuffer(uint3 id : SV_DispatchThreadID)
{
    float4 pos = float4(id.xy / _Resolution, 0, 0);
    float4 buffer = tex2Dlod(_GridBuffer, pos);
    _Result[id.xy] = buffer;
}