#pragma kernel Init
#pragma kernel Next
#pragma kernel ClearGreenChannel
#pragma kernel ApplyBuffer

#include "Random.cginc"

float _Resolution;
uint _Iterations;
RWTexture2D<float4> _Result;
sampler2D _GridBuffer;
float4 _SpawnData; // XY = Position, Z = Radius, W = Type.

float4 GetUV(uint3 id)
{
    return float4(id.xy / _Resolution, 0, 0);
}

float4 SampleNeighbour(float4 position, float dx, float dy)
{
    return tex2Dlod(_GridBuffer, position + float4(dx, dy, 0, 0));
}

float Distance(float2 a, float2 b)
{
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

void MoveDown(uint3 id, float4 state)
{
    _Result[id.xy] = float4(0, 1, 0, 0);
    _Result[id.xy - uint2(0, 1)] = float4(state.x, 1, state.zw);
}
void MoveDownLeft(uint3 id, float4 state)
{
    _Result[id.xy] = float4(0, 1, 0, 0);
    _Result[id.xy - uint2(1, 1)] = float4(state.x, 1, state.zw);
}
void MoveDownRight(uint3 id, float4 state)
{
    _Result[id.xy] = float4(0, 1, 0, 0);
    _Result[id.xy - uint2(-1, 1)] = float4(state.x, 1, state.zw);
}
void MoveLeft(uint3 id, float4 state)
{
    _Result[id.xy] = float4(0, 1, 0, 0);
    _Result[id.xy - uint2(1, 0)] = float4(state.x, 1, state.zw);
}
void MoveRight(uint3 id, float4 state)
{
    _Result[id.xy] = float4(0, 1, 0, 0);
    _Result[id.xy - uint2(-1, 0)] = float4(state.x, 1, state.zw);
}

[numthreads(8,8,1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    // TODO: Init a rock cavern pattern using cellular automaton.
    _Result[id.xy] = 0;
}

[numthreads(8,8,1)]
void Next(uint3 id : SV_DispatchThreadID)
{
    float4 uv = GetUV(id);
    float delta = 1.0 / _Resolution; // Cells neighbour distance.
    
    float4 state = tex2Dlod(_GridBuffer, uv);

    // Neighbours state.
    float4 downState = SampleNeighbour(uv, 0, -delta);
    float4 downRightState = SampleNeighbour(uv, delta, -delta);
    float4 downLeftState = SampleNeighbour(uv, -delta, -delta);
    float4 rightState = SampleNeighbour(uv, delta, 0);
    float4 leftState = SampleNeighbour(uv, -delta, 0);
    
    if (state.x == 1) // Sand.
    {
        if (uv.y > 0)
        {
            if (downState.x == 0)
            {
                MoveDown(id, state);
            }
            else
            {
                if (hash21(id.xy) > 0.5)
                {
                    if (downRightState.x == 0 && rightState.x == 0)
                        MoveDownRight(id, state);
                    else if (downLeftState.x == 0 && leftState.x == 0)
                        MoveDownLeft(id, state);
                }
                else
                {
                    if (downLeftState.x == 0 && leftState.x == 0)
                        MoveDownLeft(id, state);
                    else if (downRightState.x == 0 && rightState.x == 0)
                        MoveDownRight(id, state);
                }
            }
        }
    }
    else if (state.x == 3) // Water.
    {
        if (uv.y > 0 && downState.x == 0)
        {
            MoveDown(id, state);
        }
        else
        {
            // TODO: Randomize water horizontal direction and flip it on collision.
            
            if (hash21(id.xy) > 0.5)
            {
                if (uv.y > 0 && downRightState.x == 0 && rightState.x == 0)
                {
                    state.z = 1;
                    MoveDownRight(id, state);
                }
                else if (uv.y > 0 && downLeftState.x == 0 && leftState.x == 0)
                {
                    state.z = -1;
                    MoveDownLeft(id, state);
                }
                else
                {
                    if (state.z == 0)
                        state.z = 1;

                    if (state.z == 1)
                    {
                        if (uv.x < 1 && rightState.x == 0)
                        {
                            if (_Result[id.xy + uint2(1, 0)].x == 0)
                                MoveRight(id, state);
                        }
                        else
                        {
                            state.z = -1;
                            _Result[id.xy] = state;
                        }
                    }
                    else if (state.z == -1)
                    {
                        if (uv.x > 0 && leftState.x == 0)
                        {
                            if (_Result[id.xy - uint2(1, 0)].x == 0)
                                MoveLeft(id, state);
                        }
                        else
                        {
                            state.z = 1;
                            _Result[id.xy] = state;
                        }
                    }
                }
            }
            else
            {
                if (uv.y > 0 && downLeftState.x == 0 && leftState.x == 0)
                {
                    state.z = -1;
                    MoveDownLeft(id, state);
                }
                else if (uv.y > 0 && downRightState.x == 0 && rightState.x == 0)
                {
                    state.z = 1;
                    MoveDownRight(id, state);
                }
                else
                {
                    if (state.z == 0)
                        state.z = -1;

                    if (state.z == 1)
                    {
                        if (uv.x < 1 && rightState.x == 0)
                        {
                            if (_Result[id.xy + uint2(1, 0)].x == 0)
                                MoveRight(id, state);
                        }
                        else
                        {
                            state.z = -1;
                            _Result[id.xy] = state;
                        }
                    }
                    else if (state.z == -1)
                    {
                        if (uv.x > 0 && leftState.x == 0)
                        {
                            if (_Result[id.xy - uint2(1, 0)].x == 0)
                                MoveLeft(id, state);
                        }
                        else
                        {
                            state.z = 1;
                            _Result[id.xy] = state;
                        }
                    }
                }
            }
        }
    }
    
    if (_SpawnData.w > -1 && Distance(uv.xy, _SpawnData.xy) < (_SpawnData.z / 2) / _Resolution)
        _Result[id.xy] = float4(_SpawnData.w, 1, 0, 0);
}

[numthreads(8,8,1)]
void ClearGreenChannel(uint3 id : SV_DispatchThreadID)
{
    float4 uv = GetUV(id);
    float4 state = tex2Dlod(_GridBuffer, uv);
    _Result[id.xy] = float4(state.x, 0, state.zw);
}

[numthreads(8,8,1)]
void ApplyBuffer(uint3 id : SV_DispatchThreadID)
{
    float4 pos = float4(id.xy / _Resolution, 0, 0);
    float4 buffer = tex2Dlod(_GridBuffer, pos);
    _Result[id.xy] = buffer;
}